# 8장 함수

# 1. 함수 정의하기

---

함수를 정의하는 네 가지 방법

### 1. 함수 선언문으로 정의하는 방법

```jsx
function square(x) {
  return x * x;
}
```

### 2. 함수 리터럴로 정의하는 방법

```jsx
var square = function (x) {
  return x * x;
};
```

### 3. Function 생성자로 정의하는 방법

```jsx
var square = new Function('x', 'return x*x');
```

### 4. 화살표 함수 표현식으로 정의하는 방법

```jsx
var square = (x) => x * x;
```

자바스크립트는 함수 선언문을 프로그램의 첫머리 또는 함수의 첫머리로 끌어올린다.

나머지는 참조를 변수에 할당한 후에 호출 가능하다.

특정 함수의 내부에 선언된 함수를 그 함수의 중첩 함수라고 한다. 또는 지역 함수, 내부 함수라고 부르기도 하지만 중첩 함수가 맞는 표현이다.

```jsx
function norm(x) {
  var sum2 = sumSquare();
  return Math.sqrt(sum2);
  function sumSquare() {
    sum = 0;
    for (var i = 0; i < x.length; i++) sum += x[i] * x[i];
    return sum;
  }
}
var a = [2, 1, 3, 5, 7];
var n = norm(a);
console.log(n); // → 9.38083151964686
```

중첩 함수의 참조는 그 중첩 함수를 둘러싼 외부 함수의 지역 변수에 저장되므로 외부 함수의 바깥에서는 읽거나 쓸 수 없다.

자신을 둘러싼 외부 함수의 인수와 지역 변수에 접근할 수 있다.

# 2. 함수 호출하기

---

함수를 호출하는 네 가지 방법

### 1. 함수 호출

함수의 참조가 저장된 변수 뒤에 ()를 붙여서 함수를 호출한다.

```jsx
var s = square(5);
```

### 2. 메서드 호출

객체의 프로퍼티에 저장된 값이 함수 타입이면 그 프로퍼티를 메서드라고 부른다. 메서드를 호출할 때는 ()를 붙여서 호출한다.

```jsx
obj.m = fuction() { . . . };
obj.m();
```

### 3. 생성자 호출

함수의 참조를 저장한 변수 앞에 new 키워드를 추가하면 함수가 생성자로 동작한다.

```jsx
var obj = new Object();
```

### 4. call, apply를 사용한 간접 호출

나중에 자세히 배운다.

자바스크립트에는 익명 함수를 정의하고 곧바로 실행하는 **즉시 실행 함수**라는 구문이 있다.

```jsx
(function() { . . .})();
or
(function() { . . .}());
(function(a, b) { . . .})(1,2); // 즉시 실행 함수에도 인수를 넘길 수 있다.
```

함수 이름을 붙일 수도 있지만 함수 이름은 함수 내부에서만 유효하다.

# 3. 함수의 인수

---

자바스크립트에서는 인수의 개수보다 더 많은 인수를 넘길 수도 있고, 호출 시 인수를 생략할 수도 있다.

함수 정의식에 작성된 인자 개수보다 인수를 적게 전달해서 함수를 실행하면 인수에서 생략한 인자는 undefined가 된다.

인수를 생략할 수 있는 함수를 정의할 수 있다. 구현하려면 인수를 생략했을 때 사용할 초깃값을 설정해야 한다.

```jsx
function multiply(a, b) {
  b = b || 1; // b의 초깃값을 1로 설정
  return a * b;
}
multiply(2, 3); // -> 6
multiply(2); // -> 2
```

arguments 객체를 사용하여 인수를 받을 수 있다.

length와 callee를 가지고 있다.

length: 인수 개수

callee: 현재 실행되고 있는 함수의 참조

arguments[0] : 1번째 인수 값

arguments[1] : 2번째 인수 값

```jsx
function myConcat(separator) {
  var s = '';
  for (var i = 1; i < arguments.length; i++) {
    s += arguments[i];
    if (i < arguments.length - 1) s += separator;
  }
  return s;
}
console.log(myConcat('/', 'apple', 'orange', 'peach')); // → apple/orange/peach
```

arguments는 유사 배열 객체이다.

```jsx
var params = [].slice.call(arguments);
```

# 4. 재귀 함수

---

재귀 호출: 함수가 자기 자신을 호출하는 행위

재귀 함수: 재귀 호출을 수행하는 함수

재귀 함수 정의 시 유의할 점

1. 재귀 호출은 반드시 멈춰야 한다.
2. 재귀 호출로 문제를 간단하게 해결할 수 있을 때만 사용한다.

호출된 횟수만큼 메모리 소비량이 늘어난다. 반복문을 재귀 함수로 바꾸어 표현할 수는 있지만 대부분 while문이나 for문으로 작성하는 편이 이해하기 쉽고 메모리 공간도 적게 차지한다.

# 5. 프로그램의 평가와 실행 과정

---

자바스크립트 엔진은 실행 가능한 코드를 만나면 그 코드를 평가해서 실행 문맥으로 만든다. 실행 가능한 코드의 유형은 세 가지이다.

- 전역 코드
- 함수 코드
- eval 코드

실행 문맥은 실행 가능한 코드가 실제로 실행되고 관리되는 영역으로 실행에 필요한 모든 정보를 컴포넌트 여러 개가 나누어 관리하도록 만들어져 있다.

- 렉시컬 환경 컴포넌트
- 변수 환경 컴포넌트
- 디스 바인딩 컴포넌트

1, 2번은 렉시컬 환경 타입의 컴포넌트이다. 타입이 같고 똑같이 취급해도 무리가 없다.

3번은 그 함수를 호출한 객체의 참조가 저장되는 곳. 이것이 가리키는 값이 곧 해당 실행 문맥의 this가 된다.

```jsx
// 실행 문맥
ExecutionContext = {
  // 렉시컬 환경 컴포넌트
  LexcialEnvironment: {},
  // 변수 환경 컴포넌트
  VariableEnvironment: {},
  // 디스 바인딩 컴포넌트
  ThisBinding: null,
};
```

**렉시컬 환경 컴포넌트**는 자바스크립트 코드를 실행하기 위해 자원을 모아 둔 곳. 구체적으로는 함수 또는 블록의 유효 범위 안에 있는 식별자와 그 결괏값이 저장되는 곳. 식별자와 식별자가 가리키는 값을 키와 값의 쌍으로 바인드해서 렉시컬 환경 컴포넌트에 기록한다.

```jsx
// 렉시컬 환경 컴포넌트
LexicalEnvironment: {
	// 환경 레코드
	EnvironmentRecord: {},
  // 외부 렉시컬 환경 참조
	OuterLexicalEnvironment Reference: {}
}
```

렉시컬 환경 컴포넌트는 **환경 레코드**와 **외부 렉시컬 환경 참조** 컴포넌트로 구성되어 있다.

환경 레코드: 유효 범위 안에 포함된 식별자를 기록하고 실행하는 영역. 식별자와 결괏값을 바인드해서 환경 레코드에 기록한다.

**외부 렉시컬 환경 참조**: 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조가 저장된다. 중첩된 함수 안에서 바깥 코드에 정의된 변수를 사용할 때 필요하다.

환경 레코드는 렉시컬 환경 안의 식별자와 그 식별자가 가리키는 값의 묶음이 실제로 저장되는 영역이다. **선언적 환경 레코드**와 **객체 환경 레코드**로 구성되어 있다.

선언적 환경 레코드: 함수와 변수, catch문의 식별자와 실행 결과가 저장되는 영역

객체 환경 레코드: 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 쓴다.

```jsx
// 환경 레코드
EnvironmentRecord: {
	// 선언적 환경 레코드
	DeclarativeEnvironmentRecord: {},
	// 객체 환경 레코드
	ObjectEnvironmentRecord: {}
}
```

자바스크립트 인터프리터는 시작하자마자 렉시컬 환경 타입의 전역 환경을 생성. 웹 브라우저에 내장된 자바스크립트 인터프리터는 새로운 웹 페이지를 읽어들인 후 전역 환경 생성. 전역 객체를 생성한 다음 전역 환경의 객체 환경 레코드에 전역 객체의 참조를 대입.

```jsx
// 전역 환경
GlobalEnvironment = {
  ObjectEnvironmentRecord: {
    bindObject: window,
  },
  OuterLexicalEnvironmentReference: null,
};
// 전역 실행 문맥
ExecutionContext = {
  LexicalEnvironment: GlobalEnvironment,
  ThisBinding: window,
};
```

전역 코드를 평가할 때 최상위 레벨에 var 문으로 작성한 전역 변수를 전역 환경의 환경 레코드에 프로퍼티로 기록한다. 프로퍼티 이름은 식별자 이름이 되고 프로퍼티 값은 undefined가 된다. 함수의 경우에는 최상위 레벨에 작성된 함수 선언문을 함수 객체로 생성해서 전역 환경의 환경 레코드에 프로퍼티로 기록한다.

최상위 레벨에 선언된 변수와 함수는 프로그램을 평가하는 시점에 환경 레코드에 추가된다. 최상위 레벨에 선언된 함수와 변수는 프로그램을 평가하는 단계에 이미 객체 환경 레코드에 추가된 상태이기 때문에 코드의 어느 위치에 작성해도 전체 프로그램이 참조할 수 있다. 이게 ‘끌어올림’이다.

var 선언문과 함수 선언문으로 선언한 전역 변수는 [[Configuable]]속성이 false로 설정되어 있어서 delete 연산자로 삭제할 수 없다.

프로그램이 평가된 후 프로그램이 실행된다. 프로그램은 실행 문맥 안에서 실행된다.

실행 문맥은 **스택**이라는 구조로 관리된다. 스택은 후입선출 방식으로 관리된다. push, pop의 행위가 있다.

처음에 전역 코드의 실행 문맥이 push되고, 함수가 실행되면 함수의 실행 문맥을 push한다. 함수의 작업이 끝나면 함수의 실행 문맥을 스택에서 pop한다. 중첩 함수는 실행 문맥을 새로 만들어서 push한다. 재귀 함수도 마찬가지이다.

프로그램 실행 방식에는 **싱글 스레드** 방식과 **멀티 스레드** 방식이 있다.

스레드: 프로그램의 처리 흐름

싱글 스레드 방식: 프로그램 한 개의 처리 흐름으로 프로그램을 순차적으로 실행하는 방식이다.

멀티 스레드 방식: 프로그램 여러 개의 처리 흐름으로 동시에 작업을 여러 개 병렬로 실행하는 방식이다.

자바스크립트는 싱글 스레드 방식을 사용한다. 호출 스택에 쌓인 실행 문맥을 위에서부터 아래로 차례차례 실행한다. 실행 문맥 하나의 작업이 끝나면 pop하고, 아래에 있는 실행 문맥을 실행한다.

이벤트 처리와 비동기 처리도 똑같은 방식이다. 실행할 준비가 끝난 이벤트 처리기 함수와 비동기 처리는 이벤트 큐에 대기 행렬을 만든다. 그리고 현재 실행 중인 함수의 작업이 끝나면 대기 행렬에서 실행을 기다리는 첫 번째 실행 문맥부터 차례대로 호출 스택에 push해서 실행한다. 대기 행렬은 선입 선출이다.

함수 호출 → 실행 문맥 영역 생성 → 프로그램 실행 흐름이 그 실행 문맥으로 이동 → 함수의 실행 문맥이 호출 스택이 push → 실행 문맥 안에 렉시컬 환경 컴포넌트 생성.

렉시컬 환경 컴포넌트는 환경 레코드를 가지고 있다. 환경 레코드에는 함수 안팎의 환경을 기록한다. 다음과 같은 정보를 기록한다.

- 함수의 인자
- 함수 안에서 선언된 중첩 함수의 참조
- 함수 안에서 var로 선언한 지역 변수
- arguments

함수의 실행 문맥, 렉시컬 환경, 환경 레코드가 생성되면 실행 문맥에 있는 디스 바인딩 컴포넌트에 그 함수를 호출한 객체의 참조를 저장하며 이것으로 this 값을 결정한다. 환경 레코드와 this 값이 결정되면 함수 안의 코드가 순서대로 실행된다.

함수가 종료되어 제어권이 호출한 코드로 돌아가면 일반적으로 실행 문맥과 함께 그 안에 있는 렉시컬 환경 컴포넌트가 메모리에서 지워진다. 하지만 그 함수의 바깥에 위치한 함수의 참조가 환경 레코드에 유지되는 경우에는 렉시컬 환경 컴포넌트가 메모리에서 지워지지 않는다.

함수가 호출되어 실행되는 시점에 this 값이 결정된다.

this 값: 함수가 호출되었을 때 그 함수가 속해 있던 객체의 참조

식별자 결정: 변수 x가 어디에서 선언된 변수인지 결정하는 작업

자바스크립트의 식별자 결정 규칙: 좀 더 안쪽 코드에 선언된 변수를 사용한다.

속박 변수: 함수의 인수와 지역 변수

자유 변수: 그 외 변수

닫힌 함수: 속박 변수만 포함한 함수

열린 함수: 자유 변수를 가지고 있는 함수

만약 변수를 그 함수의 환경 레코드 안에서 찾을 수 있다면, 그것으로 변수를 결정.

하지만 변수를 그 함수의 환경 레코드 안에서 찾을 수 없다면, 외부 렉시컬 환경 참조를 따라 함수를 호출한다. 거기서 변수를 찾으면 그것으로 변수를 결정하고, 아니라면 계속 외부 렉시컬 환경 참조를 따라간다.

이러한 논리적인 연결고리를 **유효 범위 체인**이라고 부른다.

사용하지 않는 객체의 메모리 영역은 가비지 컬렉터가 자동으로 해제한다. 이 메커니즘을 가비지 컬렉션이라고 한다. 최근 주요 웹 브라우저는 **마크 앤 스윕** 알고리즘을 사용한다. 전역 객체가 참조할 수 없는 객체를 검색하고 해당하는 객체가 있다면 필요 없는 객체라고 판단하여 메모리에서 해제하는 방식이다.

# 6. 클로저

---

자바스크립트의 모든 함수는 클로저를 정의한다.

클로저: 자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행한다.

자바스크립트의 클로저는 함수 객체와 렉시컬 환경 컴포넌트의 집합이다.

자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부 함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있다. 이러한 함수를 클로저라고 부른다.

# 7. 이름 공간

---

전역 변수와 전역 함수를 전역 객체에 선언하는 행위를 전역 유효 범위를 오염시킨다고 한다.

전역 유효 범위 안에서 이름이 같은 변수나 함수를 선언하면 자바스크립트 엔진이 그 프로그램의 첫머리로 끌어올려서 변수 또는 함수를 단 하나만 생성한다. 그러면 다른 목적의 코드가 같은 변수와 함수를 공유해서 프로그램이 올바르게 동작하지 않는다. 거기다 오류 표시도 되지 않는다.

전역 변수의 오염을 방지하기 위한 몇 가지 기법

1. 객체를 이름 공간으로 활용하기

이름 공간: 변수 이름과 함수 이름을 한 곳에 모아 두어 이름 충돌을 방지하고, 변수와 함수를 쉽게 가져다 쓸 수 있게 만든 메커니즘.

객체를 값으로 가지는 전역 변수를 하나 생성 → 프로그램 전체에서 사용하는 모든 변수와 함수를 프로퍼티로 정의.

부분 이름 공간을 만들 수도 있다.

1. 함수를 이름 공간으로 활용하기

라이브러리를 읽어 들여서 사용할 때 라이브러리 안에 있는 전역 변수와 충돌하지 않도록 하려면 전체 프로그램을 즉시 함수 안에 넣어서 실행한다.

```jsx
(function () {
  // 이 곳에 프로그램 작성
})();
```

모듈: 기능(함수) 여러 개를 하나로 묶은 것

모듈은 함수 여러 개와 함수가 공유하는 데이터로 구성된다. 모듈 여러 개를 사용하면 이름이 충돌할 가능성이 있다. 모듈을 즉시 실행 함수 안에 작성하여 실행하면 이름이 충돌하는 상황을 피할 수 있다. 즉시 실행 함수에 객체로 구현한 이름 공간을 전역 변수로 넘겨서 공개할 함수를 이름 공간에 추가하도록 한다. 이를 통해 모듈의 내부 구조는 은폐하고 원하는 함수만 공개한다.

# 8. 객체로서의 함수

---

자바스크립트의 함수는 Function 객체이다.

일급 객체인 함수를 일급 함수라고 한다.

함수는 Fuction 생성자의 prototype 객체의 프로퍼티를 상속받아서 사용한다.

| apply() | 선택한 this와 인수를 사용하여 함수를 호출. 인수는 배열 객체.        |
| ------- | ------------------------------------------------------------------- |
| bind()  | 선택한 this와 인수를 적용한 새로운 함수를 반환.                     |
| call()  | 선택한 this와 인수를 사용하여 함수를 호출. 인수는 쉼표로 구분한 값. |

apply 메서드, call 메서드의 동작은 본질적으로 같다. apply의 인수는 배열이고, call의 인수는 쉼표로 구분한 값의 목록이다.

bind 메서드는 객체에 함수를 바인드한다.

```jsx
function say(greetings, honorifics) {
  console.log(greetings + ' ' + honorifics + this.name);
}
var tom = { name: 'Tom Sawyer' };
var sayToTom = say.bind(tom);
sayToTom('Hello', 'Mr.');
```

함수에도 프로퍼티를 추가할 수 있다. 함수의 프로퍼티에는 일반적으로 그 함수의 작업과 관련된 데이터와 메서드를 저장한다. 이런 예시로 **메모이제이션**이 있다.

메모이제이션: 함수를 호출했을 때의 인수와 반환값을 한 쌍으로 만들어 저장해 두는 기법

메모이제이션을 함수에 적용해두면 추가적인 계산을 생략할 수 있다.

# 9. 고차 함수

---

고차 함수: 인수로 받는 함수 또는 함수를 반환하는 함수를 말한다. 함수형 프로그래밍을 할 때 자주 사용된다.

합성 함수도 만들 수 있다

```jsx
function compose(f, g) {
  return function (x) {
    return f(g(x));
  };
}
```

부분 적용: 인수를 여러 개 받는 함수의 몇몇 인수를 상수로 지정해서 새로운 함수를 생성하는 기법

```jsx
function product(x, y) {
  return x * y;
}
product2 = function (y) {
  return product(2, y);
};
product2(3); // -> 6

// product2를 bind 메서드를 사용하여 바꾸기
product2 = product.bind(null, 2);
```

코드를 이렇게 수정하면 bind 메서드의 두 번째 이후 인수가 원래 함수의 왼쪽부터 오른쪽으로 할당된다.

커링: 인수를 두 개 이상 받는 함수를 분해하여 인수가 하나인 함수의 중첩 함수로 변환하는 작업

# 10. 콜백 함수

---

콜백 함수: 다른 함수에 인수로 넘겨지는 함수

콜백 함수는 함수를 호출할 때 무언가 새로운 일이 생기거나 그 함수의 실행이 끝나면 지정한 콜백 함수를 실행해 주도록 함수에 요청해야 할 때 사용한다.

이벤트 처리기를 콜백 함수로 만들 수 있다.

```jsx
button.onclick = function() {. . .};

// 콜백 함수로 만들기
button. addEventListener("click", function() { . . .}, false);
```

# 11. ECMAScript 6부터 추가된 함수의 기능

---

화살표로 함수 표현식을 작성할 수 있다.

```jsx
// 기존 함수 리터럴
var square = function (x) {
  return x * x;
};
// 화살표 함수 표현식
var square = (x) => {
  return x * x;
};
var square = (x) => x * x;
// 즉시 실행 함수
((x) => x * x)(3); // -> 9
```

함수 리터럴과 화살표 함수의 차이점

1. this의 값이 함수를 정의할 때 결정된다.

함수 리터럴은 함수 호출 시 결정, 화살표 함수는 함수 정의 시 결정

1. arguments 변수가 없다.
2. 생성자로 사용할 수 없다.
3. yield 키워드를 사용할 수 없다.

나머지 매개변수

함수의 인자가 들어가는 부분에 …을 입력하면 그만큼의 인수를 배열로 받을 수 있다. …으로 표현한 인자를 나머지 매개변수라고 한다.

```jsx
function f(a, b, ...args) {
  console.log(a, b, args);
}
f(1, 2, 3, 4, 5, 6); // -> 1, 2, [3, 4, 5, 6]
```

함수의 인자에 = 연산자를 사용해서 기본값을 설정할 수 있다.

이터레이션: 반복 처리라는 뜻으로 데이터 안의 요소를 연속적으로 꺼내는 행위

이터레이터: 반복 처리가 가능한 객체

자바스크립트에는 Symbol.iterator 메서드를 가지고 있다. 이것은 특별한 의미를 가진 심벌이고 @@iterator라고 표기하고 이터레이터 심벌이라고 읽는다. 배열의 Symbol.iterator 메서드는 이터레이터를 반환하는 함수이다.

```jsx
var a = [5, 4, 3];
var iter = a[Symbol.iterator]); // a의 이터레이터를 iter에 대입
console.log(iter.next()); // -> Object {value: 5, done: false}
console.log(iter.next()); // -> Object {value: 4, done: false}
console.log(iter.next()); // -> Object {value: 3, done: false}
console.log(iter.next()); // -> Object {value: undefined, done: true}
console.log(iter.next()); // -> Object {value: undefined, done: true}
```

iter의 next를 호출할 때마다 이터레이터 리절트라는 객체가 반환된다. 여기에는 value와 done 프로퍼티를 가지고 있다. value 프로퍼티에는 차례대로 꺼내진 배열 요소의 값이 저장, done 프로퍼티에는 요소의 열거가 끝났는지를 뜻하는 논리값이 저장된다.

for/of 문을 사용하면 자동으로 반복 처리를 하게 한다.

```jsx
var a = [5, 4, 3];
for (var v of a) console.log(v);
```

for/of문은 두 가지 조건을 만족하는 객체를 반복 처리한다.

- Symbol.iterator 메서드를 가지고 있다. → 이터러블한 객체
- Symbol.iterator 메서드는 반환값으로 이터레이터를 반환한다.

이터레이터와 이터레이터한 객체는 다른 개념의 객체이다.

제너레이터

- 반복 가능한 이터레이터를 값으로 반환한다.
- 작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리한다.

제너레이터는 function\*문으로 정의한 함수이며, 하나 이상의 yield 표현식을 포함한다.

```jsx
function* gen() {
  yield 1; // 포인트 1
  yield 2; // 포인트 2
  yield 3; // 포인트 3
}
var iter = gen();
console.log(iter.next()); // -> Object {value: 1, done: false}
console.log(iter.next()); // -> Object {value: 2, done: false}
console.log(iter.next()); // -> Object {value: 3, done: false}
console.log(iter.next()); // -> Object {value: 1, done: true}
```

제너레이터 함수는 호출해도 바로 실행되지 않고 이터레이터를 반환

next 메서드가 호출되면 yield 연산자의 위치까지 실행. 결괏값으로 이터레이터 리절트를 반환. 그리고 다시 next를 부를 때까지 정지상태가 된다.

제너레이터 함수의 yield는 프로그램이 일시적으로 정지하는 위치이다.

next 메서드에 넘긴 값은 제너레이터가 일시적으로 정지하기 직전의 yield 표현식의 값으로 사용된다.

return 메서드를 실행하면 인수값을 반환하고 종료한다.

throw 메서드를 실행하면 예외를 제너레이터에 던질 수 있다.

yield* 표현식도 사용할 수 있다. yield*에는 반복 가능한 객체를 지정한다. 그러면 이터러블한 객체에서 순차적으로 값을 꺼내 각각의 값에 yield를 적용한다.

템플릿 리터럴 앞에 함수 이름을 적으면 템플릿 리터럴의 내용을 인수로 받는 함수를 호출할 수 있다.

```jsx
func`${a} + ${b} = ${a + b}`;
```

func 부분을 태그 함수라고 한다. 태그 함수의 첫 번째 인수는 템플릿 리터럴 안의 문자열을 ${…}를 기준으로 분할한 문자열이다. 두 번째 이후 인수로는 ${…}안에 지정된 표현식을 평가한 값이 순서대로 들어간다.

태그 함수의 첫 번째 인수는 callSite 객체라고 하며 다음과 같은 특징이 있다.

- 동결되어 있다. 읽기만 가능
- 캐시된다. 이전에 처리했던 템플릿 리터럴 문자열을 만나면 캐시된 callSite 객체를 첫 번째 인수로 넘긴다
- raw 프로퍼티가 있다. raw 프로퍼티 값은 배열이다. raw 프로퍼티는 템플릿 요소의 첫 번째 인수의 배열과 같다. 하지만 이스케이프 되지 않은 문자열이 들어온다.

# 9장 객체

# 1. 객체 생성하기

---

객체 생성하는 세 가지 방법

1. 객체 리터럴로 생성하는 방법
2. 생성자로 생성하는 방법
3. Object.create로 생성하는 방법

```jsx
var card = Object.create(Object.prototype, {
  suit: {
    value: '하트',
    writable: true,
    enumerable: true,
    configurable: true,
  },
  rank: {
    value: 'A',
    writable: true,
    enumerable: true,
    configurable: true,
  },
});
```

생성자 안에서 this 뒤에 메서드를 정의하면 그 생성자로 생성한 모든 인스턴스에 똑같은 메서드가 추가된다. 그래서 인스턴스를 여러 개 생성하면 같은 작업을 하는 메서드를 인스턴스 개수만큼 생성한다. 따라서 메모리를 소비하게 된다.

함수 객체는 기본적으로 prototype 프로퍼티를 가지고 있다. prototype 프로퍼티가 가리키는 객체를 그 함수의 프로토타입 객체라고 한다. 기본적으로 빈 객체를 가리킨다. 프로토타입 객체의 프로퍼티는 생성자로 생성한 모든 인스턴스에서 그 인스턴스의 프로퍼티처럼 사용할 수 있다.

```jsx
F.prototype.prop = 'prototype value';
var obj = new F();
console.log(obj.prop); // -> prototype value
```

프로토타입 객체의 프로퍼티는 읽기만 가능하고 수정이 불가능하다.

프로토타입 메서드를 추가하면 인스턴스 안에는 그 메서드가 존재하지 않지만 메서드를 사용할 수 있다.

# 2. 프로토타입 상속

---

자바스크립트에서는 객체를 상속한다. 프로토타입 상속이라고 부른다.

내부 프로퍼티 [[Prototype]]

모든 객체는 이걸 가지고 있다. 주요 웹 브라우저는 **proto**프로퍼티를 지원한다.

객체의 **proto** 프로퍼티는 그 객체에게 상속을 해 준 부모 객체를 가리킨다. 따라서 객체는 부모 객체의 프로퍼티를 사용할 수 있다.

```jsx
var objA = {...}
var objB = {...}
objB.__proto__ = objA;
```

자신의 객체 안에서 메서드를 찾고 없으면 **proto**가 가리키는 객체에서 찾는 방식으로 올라간다. 이와 같은 객체의 연결 고리를 **프로토타입 체인**이라고 한다. 부모 객체를 자식 객체의 **프로토타입**이라고 한다.

이처럼 자바스크립트는 프로토타입 체인을 사용하여 객체의 프로퍼티를 다른 객체로 전파한다. 이를 **프로토타입 상속**이라고 한다. 이것을 하는 객체 지향 언어를 가리켜 **프로토타입 기반 객체 지향 언어**라고 한다.

객체의 프로토타입 가져오는 방법

```jsx
function F() {}
var obj = new F();
console.log(Object.getPrototypeOf(obj)); // -> Object {}
```

new 연산자의 역할

new 연산자로 생성자를 사용하면 다음과 같은 작업을 수행한다.

1. 빈 객체 생성
2. 객체명.prototype을 생성된 객체의 프로토타입으로 설정한다.
3. 생성자를 실행한다. 인스턴스를 초기화한다.
4. 완성된 객체를 결괏값으로 반환한다.

함수 정의 → 함수 객체는 prototype 프로퍼티를 가짐 → 이건 프로토타입 객체를 가리킴 → 이건 기본적으로 constructor와 **proto**를 가지고 있음.

constructor 프로퍼티는 함수 객체의 참조를 값으로 가지고 있다.

생성자와 프로토타입 객체는 서로를 가리키고 인스턴스는 프로토타입 객체를 가리킨다. 프로토타입 객체의 프로토타입은 Object.prototype이다.

Object.prototype의 프로토타입은 null을 가리킨다.

생성자의 prototype 프로퍼티 값을 새로운 객체로 교체할 때에는 constructor 프로퍼티에 생성자의 참조를 대입해야 한다.

인스턴스가 생성된 이후에는 생성자의 프로토타입을 바꾸어도 생성된 인스턴스는 영향을 받지 않는다.

하지만, 생성자가 가지고 있던 프로토타입 객체에 프로퍼티를 추가한 경우에는 정의한 프로퍼티를 인스턴스에서 사용할 수 있다.

instanceof 연산자는 그 인스턴스가 해당 생성자의 프로토타입 객체를 상속받았는지 확인한다.

isPrototypeOf 메서드는 특정 객체가 다른 객체의 프로토타입 체인에 포함되어 있는지 판정한다.

Object 생성자는 내장 생성자로 일반적인 객체를 생성한다.

```jsx
var obj = new Object();
var obj = {};
```

Object 생성자는 new 없이도 new를 붙여서 호출했을 때와 같은 방식으로 동작한다.

Object는 프로토타입 체인을 따라 거슬러 올라갈 수 있는 마지막 단계의 객체이다.

같은 이름의 메서드가 있다면 호출한 인스턴스와 가까운 메서드를 사용한다.

Object.create를 사용하면 명시적으로 프로토타입을 지정해서 객체를 생성한다. 이 메서드의 첫 번째 인수는 생성할 객체의 프로토타입이다.

```jsx
var person1 = {
  name: 'Tom',
  sayHello: function () {
    console.log('Hello! ' + this.name);
  },
};
var person2 = Object.create(person1);
person2.name = 'Huck';
person2.sayHello(); // -> Hello! Huck
```

# 3. 접근자 프로퍼티

---

데이터 프로퍼티: 값을 저장하기 위한 프로퍼티

접근자 프로퍼티: 값이 없음. 프로퍼티를 읽거나 쓸 때 호출하는 함수를 값 대신에 지정할 수 있는 프로퍼티.

접근자: 객체 지향 프로그래밍에서 객체가 가진 프로퍼티 값을 객체 바깥에서 읽거나 쓸 수 있도록 제공하는 메서드.

접근자 프로퍼티로 프로퍼티를 읽고 쓸 수 있게 하면 프로그램의 유지 보수성을 높일 수 있다.

접근자 프로퍼티 하나에 대해 게터 함수와 세터 함수를 정의할 수 있다.

게터 함수: 그 프로퍼티를 읽을 때의 처리를 담당

세터 함수: 그 프로퍼티를 쓸 때의 처리를 담당

게터나 세터를 정의하려면 function 대신 get이나 set 키워드를 사용한다. getter는 인수가 없고 setter는 인수가 하나 있다. 접근자 프로퍼티의 값을 읽으려고 하면 getter가 호출되고 값을 쓰려고 하면 setter가 호출된다. 접근자 프로퍼티도 데이터 프로퍼티와 마찬가지로 delete 연산자로 삭제할 수 있다. 객체 생성 후 접근자 프로퍼티를 추가하거나 생성자 안에 접근자 프로퍼티를 정의하려면 Object.defineProperty 나 Object.defineProperties 메서드를 사용한다.

즉시 실행 함수로 클로저를 생성하면 데이터를 객체 외부에서 읽고 쓸 수 없도록 숨기고 접근자 프로퍼티로만 읽고 쓰도록 만들 수 있다.

# 4. 프로퍼티의 속성

프로퍼티는 내부적인 속성을 몇 개 더 가지고 있다.

- 쓰기 가능

true → 프로퍼티 값 수정할 수 있다.

- 열거 가능

프로퍼티가 for/in문이나 Object.keys 등의 반복문으로 찾을 수 있는 대상인지

- 재정의 가능

프로퍼티의 내부 속성을 수정할 수 있는지를 뜻하는 속성

프로퍼티 디스크립터

프로퍼티의 속성 값을 뜻하는 객체이다. 이 객체가 가진 프로퍼티 이름은 프로퍼티가 가진 속성 이름과 같다.

프로퍼티 디스크립터 가져오기: **Object.getOwnPropertyDescriptor**

첫 번째 인수: 객체의 참조, 두 번째 인수: 프로퍼티 이름을 뜻하는 문자열

객체의 프로퍼티 설정하기: **Object.defineProperty**

첫 번째 인수: 객체의 참조, 두 번째 인수: 프로퍼티 이름의 문자열, 세 번째 인수: 프로퍼티 디스크립터의 참조

실행 후에는 수정한 객체의 참조를 반환한다.
