자바스크립트 - 웹 브라우저에서 동작하는 프로그래밍 언어

---

컴파일: 소스 코드를 기계어로 번역하는 행위

컴파일러: 컴파일을 수행하는 소프트웨어

컴파일 언어: 소스 코드 여러 개를 하나로 묶어서 컴파일한 후에 실행하는 프로그래밍 언어. 컴파일 시간은 걸리지만, 실행 속도가 빠름.

ex) C, C++, Java등

인터프리터 언어: 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어

장점: 프로그램 바로 실행, 동작을 확인해 가며 프로그램 개발

단점: 처리 속도가 느림

ex) 자바스크립트, LISP, Perl, Python 등

인터프리터: 프로그램을 번역해서 실행시키는 소프트웨어

프로그래밍 언어의 유형: 절차적 언어, 객체 지향 언어, 함수형 언어, 논리형 언어 등

---

1. 인터프리터 언어 - 최근 JIT 컴파일러 내장으로 인해 실행 속도가 매우 빨라짐
2. 동적 프로토타입 기반 객체 지향 언어 - 프로토타입을 상속하는 프로토타입 기반 객체 지향 언어. 객체 생성 이후에도 프로퍼티와 메서드를 동적으로 추가/삭제
3. 동적 타입 언어 - 변수 타입이 없음 → 프로그램을 실행하는 도중에 데이터 타입이 동적으로 바뀔 수 있음.
4. 함수가 일급 객체 - 함수가 객체. 함수에 함수를 인수로 넘길 수 있음.
5. 함수가 클로저를 정의한다. - 클로저로 변수 은닉, 영속성 보장 등의 기능 구현.

---

1. ECMAScript(코어 언어)
2. 클라이언트 측의 고유한 기술 요소
3. 서버 측 자바스크립트의 고유한 기술 요소

---

```jsx
function fact(n) {
  if (n <= 1) return n;
  return n * fact(n - 1);
}

for (var i = 1; i < 10; i++) {
  console.log(i + '!=' + fact(i));
}
```

코드 입력 시 주의 사항

1. 직접 작성한다
2. 세미콜론 잊지 않기

# 3. 프로그램 실행법

---

자바스크립트만으로 구성된 프로그램 실행법

1. 웹 브라우저의 콘솔에서 실행하기
2. 자바스크립트 코드를 HTML 문서에 삽입하여 웹 브라우저로 실행하기
3. Node.js의 대화형 모드로 실행하기
4. Node.js의 파일을 읽어 들여 실행하기

### 1. 웹 브라우저의 콘솔에서 실행하기

Chrome DevTools라는 개발자 도구를 사용하여 실행하기

개발자 도구 단축키: Command + Option + i

콘솔 창을 켠 뒤 입력하면 실행이 된다. 다음 줄에 입력하고 싶을 때는 Shift + Enter, 입력을 다 마치고 실행시킬 때는 Enter 입력한다.

여러 가지 단축키도 있다.

코드 실행 중 오류가 발생하면 오류 내용도 표시된다.

console.log는 소괄호 안에 든 값을 콘솔 화면에 표시하라는 뜻이다.

### 2. HTML 문서에 삽입하여 웹 브라우저로 실행하기

HTML 문서에 script 요소를 배치한 다음 script 요소 안에 자바스크립트 프로그램을 작성한다. HTML 문법을 따르는 script 요소는 위치, 개수에 제한이 없다.

```jsx
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>팩토리얼 계산</title>
  </head>
  <body>
    <script>
      function fact(n) {
        if (n <= 1) return n;
        return n * fact(n - 1);
      }

      for (var i = 1; i < 10; i++) {
        console.log(i + '!=' + fact(i));
      }
    </script>
  </body>
</html>
```

웹 브라우저로 HTML 문서를 실행시키면 콘솔창에서 실행 결과를 확인할 수 있다.

자바스크립트 프로그램이 HTML과 CSS 스타일을 제어하지 않는 순수 자바스크립트 프로그램이라면 script 요소를 body 요소에 배치한다. 그것이 아니라면 head 요소에 배치한다.

console.log를 document.write로 바꾼다면 출력 결과를 웹 페이지의 창 안에서 확인할 수 있다.

다른 파일에 저장한 자바스크립트 코드를 읽어들이는 방법

```jsx
<script src="다른 파일의 경로"></script>
```

### 3. Node.js에서 실행하기

Node.js는 주로 서버 측 자바스크립트 실행 환경으로 사용. 다양한 웹 서버 구축. 프로그램을 여러 곳에서 실행시킬 수 있음. 실행 속도가 매우 빠름.

Node.js에서 실행하려면 맥에서 터미널 사용.

대화형 모드로 키기 → 터미널에 node 입력

크롬 콘솔과 사용 방법 차이 없음.

그냥 Enter만 쳐도 Node.js가 자동으로 판단하여 여러 줄 모드로 바꿔준다. Control + c로 강제 종료할 수 있다.

편집기 모드로 바꾸기 → .editor 입력

.exit 입력, Control + c 두 번 입력, Control + d == 종료

### 4. **Node.js로 파일 읽어 들여 실행하는 법**

디렉토리를 js 파일이 있는 폴더로 설정 → node 파일의 경로 입력

ex) node factorial.js

# 4. 프로그램 작성법

---

유니코드 문자로 작성한다.

대문자와 소문자를 구별한다.

토큰(어휘): 프로그램을 구성하는 최소 단위, 의미를 가지는 최소한의 문자 덩어리

어휘 분석: 자바스크립트 인터프리터가 프로그램을 실행하기 전에 프로그램을 토큰으로 분해하는 것

구문 분석(파싱): 토큰을 한 줄로 나열하고 이것이 올바른 프로그램인지 판정

구문 분석 결과가 문제 없으면 프로그램 실행

토큰과 토큰 사이에 공백 문자를 넣어서 구분한다. 공백 문자를 여러 개 입력해도 하나만 입력한 것으로 간주한다. 산술 연산자 앞뒤의 공백 문자, 괄호 앞 뒤의 공백문자, 문장 기호 앞 뒤의 공백 문자는 생략할 수 있다.

가독성을 높이기 위해 공백 문자, 탭 문자, 개행 문자를 추가한다.

문장 끝에는 세미콜론을 붙인다. → 개행 문자로 줄을 바꾼다.

세미콜론이 자동으로 추가되기도 하지만 예상치 못한 결과를 가져올 수 있으므로 항상 세미콜론을 써준다.

주석문: /\* \*/, //

주석은 프로그램을 이해하도록 하는 설명문이다. 또는 코드 일부분을 일시적으로 실행하지 않을 때도 활용한다.(코멘트 아웃)

변수

변수: 값을 담기 위해 이름을 붙인 상자이다. 컴퓨터의 메모리에 일정한 크기의 영역으로 생성된다.

자바 스크립트에는 변수 타입이 없으므로 변수 선언자가 var 하나뿐이다.

```jsx
var sum, a;
```

변수에 값을 넣지 않으면 undefined라는 값이 들어간다.

변수를 선언하지 않은 상태에서 값을 대입하면 오류가 발생하지 않는다.

```jsx
x = 2;
console.log(x); // -> 2
```

```jsx
console.log(x);
var x;
```

위 코드를 실행하면 오류가 날 것 같지만, 실제로는 undefined가 출력된다. 프로그램 중간에서 변수를 선언하더라도 변수가 프로그램 첫 머리에 선언된 것처럼 다른 문장 앞에 생성되기 때문이다. 이것을 **변수 선언의 끌어올림**(호이스팅, hoisting)이라고 한다.

단, 선언과 동시에 대입하는 코드는 끌어올리지 않는다.

```jsx
console.log(x); // -> undefined
var x = 5;
console.log(x); // -> 5
```

두 번째 줄의 var x는 끌어올리지만 x = 5는 끌어올리지 않기 때문이다.

데이터 타입

자바스크립트에는 변수 타입이 없으므로 변수에 모든 타입의 데이터를 저장할 수 있다.

```jsx
var pi = 3.14;
console.log(pi); // -> 3.14
pi = '원주율';
console.log(pi); // -> 원주율
```

⇒ 동적 타입 언어

원시 타입: 숫자, 문자열, 논리값, undefined, null, 심벌

원시 타입에 속하지 않는 자바스크립트의 값: 객체

객체: 변수 여러 개가 모여서 만들어진 복합 데이터 타입. 객체는 참조 타입이므로 객체 타입의 값을 변수에 대입하면 변수에는 그 객체에 대한 참조가 할당된다.

리터럴: 프로그램에 직접 작성할 수 있는 상수 값

정수 리터럴과 부동소수점 리터럴이 있다.

자바스크립트를 HTML 요소에 끼워 넣을 때는 자바스크립트 프로그램을 문자열로 작성한다. 이 때, HTML 코드에는 큰따옴표를 사용하고, 자바스크립트 코드에는 작은따옴표를 사용한다.

undefined는 정의되지 않은 상태를 뜻한다.

- 값을 아직 할당하지 않은 변수의 값
- 없는 객체의 프로퍼티를 읽으려고 시도했을 때의 값
- 없는 배열의 요소를 읽으려고 시도했을 때의 값
- 아무것도 반환하지 않는 함수가 반환하는 값
- 함수를 호출했을 때 전달받지 못한 인수의 값

null은 아무것도 없음을 값으로 표현한 리터럴. 주로 프로그램에서 무언가를 검색했지만 찾지 못했을 때 아무것도 없음을 전달하기 위한 값이다.

추가된 데이터 타입

심벌

심벌은 원시 값이다. 자기 자신을 제외한 그 어떤 값과도 다른 유일무이한 값이다.

```jsx
var sym1 = Symbol(); // 생성
var sym2 = Symbol();
console.log(sym1 == sym2); //-> false : 유일무이한 값이다.

var HEART = Symbol('하트'); // 인수에 심벌의 설명을 덧붙일 수 있다.
console.log(HEART.toString()); // -> Symbol(하트) : 설명 확인하는 방법

var sym1 = Symbol.for('club'); // 문자와 연결된 심벌을 생성
var sym2 = Symbol.for('club');
console.log(sym1 == sym2); // -> true : 코드의 어느 부분에서도 같은 심벌을 공유

// Symbol.keyFor()로 문자열 구할 수 있다.
console.log(Symbol.keyFor(sym1)); // -> club
```

템플릿 리터럴

템플릿: 일부만 변경해서 반복하거나 재사용할 수 있는 틀.

템플릿 리터럴은 역따옴표로 묶은 문자열이다.

템플릿 리터럴을 사용해서 일반적인 줄 바꿈 문자를 사용할 수 있다.

```jsx
var t = `Man errs as long as
he strives.`;
```

이스케이프 시퀀스 문자를 그대로 출력하려면 템플릿 리터럴 앞에 String.raw를 붙인다. 이것은 태그 함수라고 한다.

템플릿 리터럴 안에는 플레이스 홀더를 넣을 수 있다. ${ . . .} 이를 이용하여 문자열 안에 변수나 표현식의 결괏값을 삽입할 수 있다.

```jsx
var a = 2,
  b = 3;
console.log(`${a} + ${b} = ${a + b}`); // -> 2 + 3 = 5
var now = new Date();
console.log(`오늘은 ${now.getMont() + 1} 월 ${now.getDate()} 일입니다.`);
// -> 오늘은 8 월 1 일입니다.
```

객체와 배열, 함수의 기초

객체의 기초 ① 객체 리터럴

객체는 객체 리터럴과 생성자로 생성할 수 있다.

객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것이다. **연관 배열** 또는 **사전**이라고도 부른다.

데이터 하나(이름과 값의 쌍)을 가리켜 객체의 **프로퍼티**라고 부른다. 프로퍼티의 이름 부분을 **프로퍼티의 이름** 또는 **키**라고 부른다.

```jsx
// 객체 리터럴로 객체 생성하기
var card = { suit: '하트', rank: 'A' };
card.suit; // -> 하트
card['rank']; // -> A
```

{ . . .} 부분이 객체 리터럴이다. 객체 리터럴을 변수 card에 대입하고 있다. 이름: 값으로 프로퍼티를 넣어준다. 프로퍼티끼리는 ,로 구분한다. 변수에 대입된 값을 부를 때는 마침표 연산자 또는 대괄호 연산자를 사용한다. 마침표 다음에는 문자열이 붙어 있지 않고, 대괄호 안은 문자열로 채워져 있다. 객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다. 객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성된다.

```jsx
card.value = 14; // 없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.
delete card.rank; // delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.

// in 연산자를 사용하여 프로퍼티 존재여부 확인하기
console.log('suit' in card); // -> true
console.log('color' in card); // -> false
```

변수에는 객체의 참조가 저장된다.

함수의 기초

---

함수의 입력 값: 인수

함수의 출력 값: 반환값

```jsx
// square 함수 정의
function square(x) {
  return x * x;
}
```

리턴과 값 사이에 줄바꿈을 넣는다면 리턴 다음에 세미콜론이 자동 삽입 되므로 하지 말자.

```jsx
var bark = function () {
  console.log('Bow-wow');
}; //인수 x, return x
bark(); // -> "Bow-wow"
console.log(bark()); // -> undefined
```

함수 선언문은 프로그램의 첫머리로 끌어올려진다.

함수 선언문으로 함수를 선언하면 그 함수 이름을 변수 이름으로 한 함수 객체가 만들어진다. 그리고 그 변수에 함수 객체의 참조가 저장된다.

원시 값을 인수로 넘겼을 때: 값에 의한 전달

객체를 인수로 넘겼을 때: 참조에 의한 전달

```jsx
// 함수의 인수 쉽게 넘기는 법
var parameters = {
	x: 0,
	y: 0,
	vx: 10,
	vy: 15,
	radius: 5
};

function setBallProperties(params) { . . . }
. . .
setBallProperties(parameters);
```

유효 범위: 변수에 접근할 수 있는 범위

어휘적 범위: 프로그램의 구문만으로 유효 범위를 정한다. ⇒ 자바스크립트

동적 범위: 프로그램 실행 중에 유효 범위를 정한다.

전역 변수: 함수 바깥에서 선언된 변수. 유효 범위가 전체 프로그램이다.

지역 변수: 함수 안에서 선언된 변수, 함수 인자. 유효 범위는 변수가 선언된 함수 내부이다.

전역 변수 이름 == 지역 변수 이름 → 지역 변수를 사용한다.

```jsx
// 함수 안에서 변수를 선언하지 않은 상태에서 값을 대입하면 전역 변수로 선언된다.
function f() {
  a = 'local'; // a는 전역 변수이다.
  console.log(a); // -> local
  return a;
}
f();
console.log(a); // -> local
```

let 선언자: 블록 유효 범위를 갖는 지역 변수이다.

```jsx
let x = 'outer x';
{
  let x = 'inner x';
  let y = 'inner y';
  console.log(x); // -> inner x
  console.log(y); // -> inner y
}
console.log(x); // -> outer x
console.log(y); // -> ReferenceError: y is not defined
```

const 선언자: 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수를 선언한다. let문처럼 작동하며 반드시 초기화해야 한다.

const문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.

함수 리터럴: 이름이 없는 함수. **익명 함수, 무명 함수**라고도 부른다.

함수 리터럴로 정의한 함수는 끌어올리지 않는다.

```jsx
var square = function (x) {
  return x * x;
}; // 마지막에 세미콜론 붙인다
```

객체의 프로퍼티 중 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 메서드라고 한다.

메서드는 일반적으로 메서드가 속한 객체의 내부 데이터 상태를 바꾸는 용도로 사용한다.

객체의 기초 ② 생성자

---

생성자로 객체를 생성할 때는 new 연산자를 사용한다.

```jsx
function Card(suit, rank) {
  // 객체 생성자
  this.suit = suit;
  this.rank = rank;
}
var card = new Card('하트', 'A'); // suit: "하트", rank: "A"

// 객체 리터럴로 고쳐 쓸 수 있다.
var card = {};
card.suit = '하트';
card.rank = 'A';
```

생성자 이름은 관례적으로 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용한다.

배열의 기초

배열 리터럴로 생성하기

```jsx
var evens = [2, 4, 6, 8];
```

[ . . .] 부분이 배열 리터럴이다. 왼쪽 부터 인덱스가 있다.

```jsx
var a = ['A', 'B', 'C', 'D'];
a.length = 2;
console.log(a); // -> ["A", "B"]
```

Array 생성자로도 생성할 수 있다.

```jsx
var evens = new Array(2, 4, 6, 8);
var empty = new Array();
var a = new Array(2, 4);
var x = new Array(3); // 인수가 한 개이고 그 값이 정수면 인수는 배열 길이를 뜻한다.
```

없는 배열 요소에 새로운 값을 대입하면 요소 추가

push 메소드를 사용하면 배열 끝에 요소 추가

delete 연산자를 사용하면 배열의 요소 삭제. 삭제한 요소만 사라지고 length 프로퍼티는 바뀌지 않는다.

희소 배열: 배열에 요소를 추가하거나 제거하여 인덱스가 0부터 시작되지 않는 배열.

희소 배열의 길이는 배열 요소의 개수보다 크다.

연산자

---

부수 효과가 있는 표현식: 변수 값을 바꾸는 표현식

산술 연산

---

- 정수끼리 나누어도 결과가 부동소수점이 된다.
- 나머지 연산자 %의 피연산자는 부동소수점이다.
- - 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자를 문자열로 만든다.
- 계산할 수 없는 경우에는 NaN으로 평가한다.
- true면 1, false와 null이면 0
- undefined인 경우에는 NaN

비슷한 크기의 수끼리 뺄셈을 하면 정밀도 손실이 일어난다.

문자열 제어하기

문자열을 String 객체로 변환하려면 String 생성자를 사용한다.

```jsx
var msgObj = new String('Everything is practice.');
```

원시 값을 객체로 변환하는 행위를 가리켜 원시 값을 객체로 **래핑**한다고 한다.

문자열의 각 문자에는 인덱스가 있다. charAt 메서드를 사용하면 문자열의 n번째 문자를 구할 수 있다.

문자열에서 프로퍼티를 사용하려고 하면 문자열이 자동으로 String 객체로 변환된다. 이러한 객체를 **래퍼 객체**라고 한다.

valueOf() 메서드를 사용하면 String 객체를 문자열로 변환한다.

배열처럼 대괄호 연산자에 값을 대입할 수는 없다.

논리 연산자와 관계 연산자

== : 값이 같음

=== : 값과 타입이 같음

객체 비교시에는 같은 객체인지 비교한다.

논리합과 논리곱은 마지막으로 평가한 피연산자 값을 반환한다.

ex) a && b 일 때, a가 false면 전체 문장이 거짓이 된다. 따라서 b의 값을 평가하지 않으므로 a를 반환한다.

&&은 객체의 프로퍼티를 이용할 때와 객체가 null인지 아닌지를 확인할 때 유용하게 사용된다.

||은 여러 개의 값 후보 중에서 null 또는 undefined가 아닌 값을 선택하고자 할 때 유용하게 사용된다. 또한, 인수의 초깃값을 설정할 때 유용하게 사용할 수 있다.

기타 연산

typeof 연산자는 단항 연산자이며 피연산자의 데이터 타입을 뜻하는 문자열을 반환한다.

```jsx
var s = 'ABC';
console.log(typeof s); // -> string
```
